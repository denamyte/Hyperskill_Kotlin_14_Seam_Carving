<h2>JUnit</h2>
<div class="step-text">
<p>In this topic, you will learn about automated <a class="theory-lookup" href="/learn/step/27614" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, unit testing is the practice of writing and executing tests to verify if the methods of a class are working as expected, without relying on external dependencies such as databases or web services. | This process is facilitated by the JUnit framework, which recognizes methods annotated with `@Test` as unit test methods. These methods should have clear and descriptive names that indicate the purpose of the test and the expected outcome. When dealing with dependencies in unit testing, a technique called mocking is used to simulate these dependencies and create isolated tests. This allows developers to control the behavior of these dependencies and focus on testing specific parts of their code without worrying about external factors that may affect the test result.">unit testing</a> in Kotlin and write your own unit tests. As you probably know, a unit is a piece of code that performs a single task or a unit of work. In most cases, it conforms to a class. You can write and execute tests to check if the methods of that class work as expected.</p>
<p> </p>
<p></p>
<div class="alert alert-primary"><p></p><p>Note that we use <strong>unit</strong> <strong>tests</strong> to test our program without its external dependencies such as databases, web services, and so on, which would fall into the category of <strong>integration</strong> <strong>tests</strong>.</p><p></p></div>
<p></p>
<p> </p>
<p>In Kotlin, <a class="theory-lookup not-relevant" href="/learn/step/0" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a method is a function that performs a certain operation, as opposed to a property which represents data. | Methods often contain logic, while properties contain state or data. In the context of object-oriented programming, methods define the actions that an object can perform. For instance, in a class definition, you can include methods that specify the behaviors associated with that class. These methods can then be called on instances of the class to execute the specified logic.">methods</a> may <a class="theory-lookup" href="/learn/step/4580" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a return refers to the action of a function providing a value to the caller. | When a function completes its execution, it can return a value to the point from which it was called. This value can be used for further processing or stored in a variable. In Kotlin, a function's return type is specified to indicate whether it will return a value or not. If a function does not return a value, it is specified as a Unit type, which is similar to void in other programming languages. This helps the compiler and developers understand that the function will not return a value under any circumstance. Additionally, Kotlin allows the use of expression bodies for functions, which can make the code more concise. An expression body must have a return value, which is the last expression in the body. If there is only one statement in the body, the curly braces can be omitted. It's important to note that if an expression-style function does not have a return statement, it will return the result of the last expression in the body.">return</a> values or change the <a class="theory-lookup not-relevant" href="/learn/step/0" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, an internal state refers to the current condition or value of a variable or object that can be modified, even if the variable or object itself cannot be reassigned. | This concept is similar to how variables work in Java, where you cannot change the reference of a variable, but you can modify the content of the object it references. In the context of Kotlin's coroutines library, the term internal state often refers to the current value of a StateFlow or MutableStateFlow object. These objects maintain a single value and emit updates to their associated collectors whenever their value is modified. StateFlow is an immutable object, meaning its value cannot be modified once it is set, while MutableStateFlow can be updated by modifying its value.">internal state</a> of objects. To verify the correctness of any method, you may compare the value returned by that method with the expected value or compare the internal state of an object modified by that method with the expected internal state. Of course, you can do the tests manually, but it tends to be tedious and time-consuming. That's why some frameworks were developed to provide convenient tools for automated unit testing. The most popular of them is <a href="https://junit.org/junit5/" rel="noopener noreferrer nofollow" target="_blank">JUnit</a>.</p>
<h5 id="getting-started">Getting started</h5>
<p>Let's create a simple calculator that performs basic calculations on integers and checks for even numbers:</p>
<pre><code class="language-kotlin">object Calculator {
    
    fun add(a: Int, b: Int) = a + b
    
    fun subtract(a: Int, b: Int) = a - b

    fun multiply(a: Int, b: Int) = a * b

    fun divide(a: Int, b: Int) : Int {
        if (b == 0) throw IllegalArgumentException("Divisor cannot be zero!")
        return a / b
    }

    fun isEven(a: Int) = (a % 2) == 0
}</code></pre>
<p>Our object has five methods: <code class="language-kotlin">add</code>, <code class="language-kotlin">subtract</code>, <code class="language-kotlin">multiply</code>, <code class="language-kotlin">divide</code>, and <code class="language-kotlin">isEven</code>, which we are going to test.</p>
<p>In this topic, we will use <strong>JUnit 5</strong> since it is the most recent version of the JUnit framework. JUnit 5 requires Java 8 (or higher) at runtime but can also be used to test code compiled with previous versions of the JDK.</p>
<p>To start working with JUnit 5, you need to add the required <a class="theory-lookup not-relevant" href="/learn/step/0" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a dependency is a library or a module that your project relies on to function. | It is a crucial component that your code needs to run, similar to how a car relies on an engine to operate. Dependencies are managed and added to a project using a configuration file, usually located in the `build.gradle` file. In the context of software development, managing dependencies can become increasingly complex as the size and scope of the project grow. Dependency injection is a technique used to simplify this process, resulting in code with low coupling, improved maintainability, and reusability. For Kotlin-based apps, the Koin framework is a valuable tool for managing dependencies, offering a simple, lightweight, and adaptable approach.">dependencies</a> to your project. If you use Gradle<strong> </strong>as your project build tool, add the following dependency to the <code class="language-kotlin">build.gradle</code> file:</p>
<pre><code class="language-kotlin">dependencies {
    testImplementation 'org.junit.jupiter:junit-jupiter:5.9.2'
}</code></pre>
<p>Currently, 5.9.2 is the most recent <a class="theory-lookup not-relevant" href="/learn/step/0" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a version refers to a specific release or iteration of the programming language that has been developed and made available for use. | It is represented by a number or a string that indicates the level of improvements, bug fixes, or new features introduced in that version compared to the previous ones. For instance, Kotlin 1.4.20 is a version that follows Kotlin 1.4.10, and it may contain enhancements, corrections, or additional functionalities that were not present in the earlier version.">version</a> of the framework. You can always check <a href="https://search.maven.org/artifact/org.junit.jupiter/junit-jupiter" rel="noopener noreferrer nofollow" target="_blank">Maven central</a> for the most current version of the framework.</p>
<p>Also, to correctly use Gradle with JUnit 5, add the code below to the top level of the <code class="language-kotlin">build.gradle</code> file:</p>
<pre><code class="language-kotlin">test {
    useJUnitPlatform()
}</code></pre>
<p>This tells Gradle to use <code class="language-kotlin">JUnitPlatform</code> to run the tests, otherwise, Gradle will not be able to see your tests and run them. Finally, load the Gradle changes.</p>
<h5 id="writing-tests">Writing tests</h5>
<p>Now you are ready to write your first test. Create a <a class="theory-lookup not-relevant" href="/learn/step/0" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a class is a fundamental component in object-oriented programming that serves as a blueprint for creating objects with specific properties and behaviors. | It is the most important and fundamental component in the logging package, and the standard practice is to create a logger instance for each class. A class can contain methods to perform specific tasks, and in the context of logging, it can introduce several methods to print log messages. For instance, the method is used to print log messages, taking a level object and a message as arguments. In addition to regular nested classes, Kotlin also has inner classes, which are a special case of nested classes. An inner class can access members of its outer class, making it useful in specific scenarios, such as creating a nested class for a cat's ribbon bow. Furthermore, Kotlin supports generic programming, which allows writing more abstract and reusable code.">class</a> in your project's <em>src/test/kotlin </em>folder and name it <code class="language-kotlin">CalculatorTest</code>. Test classes are named beginning with the name of the class or object they are testing, and ending with "Test"  Alternatively, if you are using IntelliJ IDEA, right-click on the class or object name and select <strong>Generate... </strong>(Alt + Insert), and then <strong>Test...</strong> in the drop-down menu. A pop-up window will appear. Leave the defaults and click OK. The IDE will then create the test class for you.</p>
<p>Inside the class, add a new method <code class="language-kotlin">testAddition</code> and annotate it with <code class="language-kotlin">@Test</code> from <code class="language-kotlin">org.junit.jupiter.api.Test</code>. This annotation tells the JUnit framework that the method is a unit test method.</p>
<pre><code class="language-kotlin">import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.assertEquals

class CalculatorTest {
    
    @Test
    fun `when adding 1 and 2 expect 3`() {
        val result = Calculator.add(1, 2)
        assertEquals(3, result)
    }
}</code></pre>
<p>Test <a class="theory-lookup not-relevant" href="/learn/step/0" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a function is a sequence of instructions that performs a specific action, such as printing data to standard output or calculating a square root. | It is a named block of code that can be invoked from a program using its name followed by parentheses. If a function takes one or more arguments (input data), they should be passed in the parentheses. Functions can return a result that can be assigned to a variable. Some functions, like regular math functions, take arguments and produce a result.">functions</a> should have clear and descriptive names that make it easy to understand the purpose of the test and identify the source of a failure or bug when running multiple tests. A common naming convention is to use the format <code class="language-kotlin">FunctionName_TestCondition_ExpectedOutcome</code>. This helps to clearly communicate the purpose of the test, including the method being tested, the inputs or conditions that the method is being called with, and the expected outcome. For example, <code class="language-kotlin">add_addingOneAndTwo_shouldReturnThree</code>. Another common naming convention is <code class="language-kotlin">When_TestCondition_Expect_ExpectedOutcome</code> which will be used in this topic. Note that there are other naming conventions for test functions. In kotlin, we can write function names with spaces as in the example above using <code class="language-kotlin">``</code>. This improves readability and allows for more human-like naming of tests. It's important to keep the naming consistent across the project so that test cases are easy to understand and identify.</p>
<p> </p>
<p></p>
<div class="alert alert-primary"><p></p><p>It's worth noting that you can also use the <code class="language-kotlin">@DisplayName("A description of the test")</code> <a class="theory-lookup" href="/learn/step/22296" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, annotations are a way of providing metadata or instructions to the compiler, IDE, or framework to handle complex tasks and make coding easier. | This metadata can be used by the IDE for efficient code suggestions or can contain documentation for both the developer and the compiler about a piece of code. Annotations can have constructors that take parameters, allowing you to pass zero or more arguments. Custom annotations can be created for a deeper understanding of built-in annotations and for creating your own library or framework.">annotation</a> to describe your tests while keeping the function name simple. This is rarely used but can be useful in certain cases.</p><p></p></div>
<p></p>
<p> </p>
<p>Inside our test method, we used the <code class="language-kotlin">add</code> method from our <code class="language-kotlin">Calculator</code> which is supposed to return the sum of 1 and 2 provided as arguments. The returned value is stored in the <code class="language-kotlin">result</code> variable. After that, we check if the expected result is the same as the actual returned value stored in <code class="language-kotlin">result</code> using the <code class="language-kotlin">assertEquals</code> method. It compares the expected value (in this case, the sum of 1 and 2 is obviously 3, given as the first argument) with the actual value returned by the method we are testing (given as the second argument) and throws <code class="language-kotlin">AssertionFailedError</code> if they are not equal.</p>
<p>To run the test in IntelliJ IDEA, click on the green icon in the gutter beside the test method then click the <strong>Run</strong> button or right-click on the test file in the project view panel and select <strong>Run CalculatorTest </strong>in the drop-down menu. The Run panel opens showing the progress and the outcome of the test. In our case, the test should pass:</p>
<p><source media="(max-width: 480px)" srcset="https://ucarecdn.com/b680947a-7d6f-40fb-ac7a-46fa79d0d658/-/stretch/off/-/resize/480x/-/format/webp/ 1x,https://ucarecdn.com/b680947a-7d6f-40fb-ac7a-46fa79d0d658/-/stretch/off/-/resize/960x/-/format/webp/ 2x,https://ucarecdn.com/b680947a-7d6f-40fb-ac7a-46fa79d0d658/-/stretch/off/-/resize/1440x/-/format/webp/ 3x" type="image/webp"/><source media="(max-width: 800px)" srcset="https://ucarecdn.com/b680947a-7d6f-40fb-ac7a-46fa79d0d658/-/stretch/off/-/resize/800x/-/format/webp/ 1x,https://ucarecdn.com/b680947a-7d6f-40fb-ac7a-46fa79d0d658/-/stretch/off/-/resize/1600x/-/format/webp/ 2x,https://ucarecdn.com/b680947a-7d6f-40fb-ac7a-46fa79d0d658/-/stretch/off/-/resize/2400x/-/format/webp/ 3x" type="image/webp"/><source srcset="https://ucarecdn.com/b680947a-7d6f-40fb-ac7a-46fa79d0d658/-/stretch/off/-/resize/1100x/-/format/webp/ 1x,https://ucarecdn.com/b680947a-7d6f-40fb-ac7a-46fa79d0d658/-/stretch/off/-/resize/2200x/-/format/webp/ 2x,https://ucarecdn.com/b680947a-7d6f-40fb-ac7a-46fa79d0d658/-/stretch/off/-/resize/3000x/-/format/webp/ 3x" type="image/webp"/><picture><source media="(max-width: 480px)" srcset="https://ucarecdn.com/b680947a-7d6f-40fb-ac7a-46fa79d0d658/-/stretch/off/-/resize/480x/-/format/webp/ 1x,https://ucarecdn.com/b680947a-7d6f-40fb-ac7a-46fa79d0d658/-/stretch/off/-/resize/960x/-/format/webp/ 2x,https://ucarecdn.com/b680947a-7d6f-40fb-ac7a-46fa79d0d658/-/stretch/off/-/resize/1440x/-/format/webp/ 3x" type="image/webp"/><source media="(max-width: 800px)" srcset="https://ucarecdn.com/b680947a-7d6f-40fb-ac7a-46fa79d0d658/-/stretch/off/-/resize/800x/-/format/webp/ 1x,https://ucarecdn.com/b680947a-7d6f-40fb-ac7a-46fa79d0d658/-/stretch/off/-/resize/1600x/-/format/webp/ 2x,https://ucarecdn.com/b680947a-7d6f-40fb-ac7a-46fa79d0d658/-/stretch/off/-/resize/2400x/-/format/webp/ 3x" type="image/webp"/><source srcset="https://ucarecdn.com/b680947a-7d6f-40fb-ac7a-46fa79d0d658/-/stretch/off/-/resize/1100x/-/format/webp/ 1x,https://ucarecdn.com/b680947a-7d6f-40fb-ac7a-46fa79d0d658/-/stretch/off/-/resize/2200x/-/format/webp/ 2x,https://ucarecdn.com/b680947a-7d6f-40fb-ac7a-46fa79d0d658/-/stretch/off/-/resize/3000x/-/format/webp/ 3x" type="image/webp"/><img alt="test run example in IntelliJ IDEA" height="721" src="https://ucarecdn.com/b680947a-7d6f-40fb-ac7a-46fa79d0d658/" width="1366"/></picture></p>
<p>We'll discuss test running more in this topic. Now go ahead and add other tests for the remaining methods of our <code class="language-kotlin">Calculator</code>.  </p>
<h5 id="assertions">Assertions</h5>
<p>The <code class="language-kotlin">Assertions</code> class of the JUnit framework has a lot of overloaded methods that will allow you to test different <a class="theory-lookup not-relevant" href="/learn/step/0" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a condition is a boolean expression that is used to control the flow of a program. | It is used in control flow statements such as `if` and `when` expressions, as well as loops like `while` and `do-while`. A condition is evaluated to either `true` or `false`, and the corresponding block of code is executed based on the result of the evaluation. Conditions can include any operation that produces a boolean value, such as comparison or logical operators. They are useful in making decisions, iterating through data, and handling different scenarios in a program.">conditions</a>. In our previous example, we only tested for equality between integers but the same method can be used to test on values of other data types such as strings.</p>
<p>Here are some useful <a class="theory-lookup not-relevant" href="/learn/step/0" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, an assertion is a mechanism used to monitor the program state and ensure that certain conditions are met. | It works by terminating the program in a fail-fast manner when it encounters a failure, which helps to quickly identify and address issues during the development stage. Assertions can be used to enforce invariants, as well as to check method preconditions and postconditions. This allows developers to ensure that their code is functioning properly and to detect and fix bugs efficiently.">assertions</a>:</p>
<table align="center" border="1" cellpadding="1" cellspacing="1"><tbody><tr><td><p><code class="language-kotlin">assertEquals</code></p></td><td><p>tests if the arguments are equal</p></td></tr><tr><td><p><code class="language-kotlin">assertTrue</code></p></td><td><p>tests if a value is <code class="language-kotlin">true</code></p></td></tr><tr><td><p><code class="language-kotlin">assertFalse</code></p></td><td><p>tests if the argument is <code class="language-kotlin">false</code></p></td></tr><tr><td><p><code class="language-kotlin">assertNull</code></p></td><td><p>tests if the argument is <code class="language-kotlin">null</code></p></td></tr><tr><td><p><code class="language-kotlin">assertNotNull</code></p></td><td><p>tests if the argument is not <code class="language-kotlin">null</code></p></td></tr><tr><td><p><code class="language-kotlin">assertThrows</code></p></td><td><p>tests if the argument throws a certain exception</p></td></tr></tbody></table>
<p> </p>
<p>All of them have overloads that accept a message of the <code class="language-kotlin">String</code> type which is displayed if the test fails. You may find detailed descriptions of these and other assertions in the <a href="https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/Assertions.html" rel="noopener noreferrer nofollow" target="_blank">official JUnit 5 documentation</a>.</p>
<p>Assuming you added the tests for the other methods of our <code class="language-kotlin">Calculator</code>, you probably used the method <code class="language-kotlin">assertEquals</code> for all the tests. At this point, you could change the test for <code class="language-kotlin">isEven</code> method to use the <code class="language-kotlin">assertTrue</code> assertion:</p>
<pre><code class="language-kotlin">...
import org.junit.jupiter.api.assertTrue

class CalculatorTest {
    
    ...

    @Test
    fun `when 2 is checked if even expect true`() {
        assertTrue(Calculator.isEven(2))
    }
}</code></pre>
<p>We could also add a test to check if our <code class="language-kotlin">division</code> method throws an <code class="language-kotlin">IllegalArgumentException</code> if the second argument provided when calling it is 0:</p>
<pre><code class="language-kotlin">...
import org.junit.jupiter.api.assertThrows

class CalculatorTest {

    ...
    
    @Test
    fun `when dividing by 0 expect IllegalArgumentException`() {
        assertThrows&lt;IllegalArgumentException&gt; {
            Calculator.divide(10, 0)
        }
    }
}</code></pre>
<p>Note that this type of <a class="theory-lookup not-relevant" href="/learn/step/0" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, an exception is an object that represents an exceptional event or error occurring during the execution of a program. | Exceptions can be caught and handled to prevent the program from crashing. When an exception is thrown, the return type is nothing, and the program will only crash if you do not handle it properly. You can create your own exceptions and choose the most appropriate type of exception for a specific event. It's recommended to find the best-fitting exception type for your exceptional event, such as using `IllegalArgumentException` instead of just `Exception`. Exception handling is done using the `try` statement, where the block contains the code that can potentially cause the exception, and the `catch` block is executed if an exception occurs.">exception</a> is passed in angle brackets and the code that throws the exception is placed in as a trailing lambda.</p>
<h5 id="running-tests">Running tests</h5>
<p>Now we have a few unit tests which we may run. You can run individual tests by clicking the green icon beside the specific test or run all the tests by clicking the green icon beside the test class.</p>
<p>Another way to run the tests is by using the terminal window. First, add the following lines to the <code class="language-kotlin">build.gradle</code> file to see a more detailed output for the executed tests:</p>
<pre><code class="language-kotlin">test {
    ...
    
    testLogging {
        events "passed", "skipped", "failed"
    } 
}</code></pre>
<p>After that, run the following command in the Terminal window (make sure you are in your project's root directory):</p>
<pre><code class="language-no-highlight">./gradlew test</code></pre>
<p>Once the tests are executed, you will get this output:</p>
<pre><code class="language-no-highlight">...
&gt; Task :test
CalculatorTest &gt; when adding 1 and 2 expect 3() PASSED
CalculatorTest &gt; when subtracting 2 from 3 expect 1() PASSED
CalculatorTest &gt; when multiplying 2 by 3 expect 6() PASSED
CalculatorTest &gt; when dividing 4 by 2 expect 2() PASSED
CalculatorTest &gt; when 2 is checked if even expect true() PASSED
CalculatorTest &gt; when dividing by 0 expect IllegalArgumentException() PASSED

BUILD SUCCESSFUL in 3s</code></pre>
<p>The output shows the task that has been executed, the names of all tests, and the status of their execution.</p>
<p> </p>
<p></p>
<div class="alert alert-warning"><p></p><p>Note that if a test method has an empty body it will be counted as PASSED. If you want to force your test to fail, you have to invoke the fail method inside it.</p><p></p></div>
<p></p>
<p> </p>
<h5 id="test-outcomes">Test outcomes</h5>
<p>So far, all our tests have passed. This proves that our <code class="language-kotlin">Calculator</code> functions correctly.</p>
<p>Let's introduce a bug in our code. Change the <code class="language-kotlin">add</code> method for our <code class="language-kotlin">Calculator</code> so that it always returns 0:</p>
<pre><code class="language-kotlin">object Calculator {
    
    fun add(a: Int, b: Int) = 0
    ...
}</code></pre>
<p>Run the tests again, using the Terminal:</p>
<pre><code class="language-no-highlight">./gradlew test</code></pre>
<p>The addition test fails as expected:</p>
<pre><code class="language-no-highlight">...
&gt; Task :test
CalculatorTest &gt; when adding 1 and 2 expect 3() FAILED
    org.opentest4j.AssertionFailedError at CalculatorTest.kt:15
CalculatorTest &gt; when subtracting 2 from 3 expect 1() PASSED
CalculatorTest &gt; when multiplying 2 by 3 expect 6() PASSED
CalculatorTest &gt; when dividing 4 by 2 expect 2() PASSED
CalculatorTest &gt; when 2 is checked if even expect true() PASSED
CalculatorTest &gt; when dividing by 0 expect IllegalArgumentException() PASSED

5 tests completed, 1 failed</code></pre>
<p>The output shows that <code class="language-kotlin">when adding 1 and 2 expect 3</code> failed with an <code class="language-kotlin">AssertionFailedError</code> at line 15 in <code class="language-kotlin">CalculatorTest.kt</code>.</p>
<p>Sometimes you may want to skip a test that was implemented. Maybe because it's testing a feature that is not yet ready for release or the feature contains bugs that are not yet fixed. To do so, annotate the test method with <code class="language-kotlin">@Disabled</code>:</p>
<pre><code class="language-kotlin">...

class CalculatorTest {
    
    @Disabled
    @Test
    fun `when adding 1 and 2 expect 3`() {
        ...
    }
}</code></pre>
<p>Run the tests again, and you will get a similar output:</p>
<pre><code class="language-no-highlight">...
&gt; Task :test
CalculatorTest &gt; when adding 1 and 2 expect 3() SKIPPED
CalculatorTest &gt; when subtracting 2 from 3 expect 1() PASSED
CalculatorTest &gt; when multiplying 2 by 3 expect 6() PASSED
CalculatorTest &gt; when dividing 4 by 2 expect 2() PASSED
CalculatorTest &gt; when 2 is checked if even expect true() PASSED
CalculatorTest &gt; when dividing by 0 expect IllegalArgumentException() PASSED

BUILD SUCCESSFUL in 3s</code></pre>
<p>The test annotated with <code class="language-kotlin">@Disabled</code> is skipped resulting in a successful build.</p>
<p>Now, fix the faulty method of our <code class="language-kotlin">Calculator</code>. Remove the <code class="language-kotlin">@Disabled</code> annotation from the addition test and then run the tests again — all of them should pass. Excellent! The bug is gone.</p>
<h5 id="conclusion">Conclusion</h5>
<p>JUnit framework provides API for unit testing Kotlin classes. With its help, you can set up and run automated tests to check the results of the execution of your units of code against desired criteria. You may run tests from your IDE or use project build tools such as Gradle. If a test fails, JUnit will show a detailed output to help you understand the reasons for it.</p>
<p>You write tests using assertions, the most frequently used of which is the <code class="language-kotlin">assertEquals</code> method. Running a test can result in either <code class="language-kotlin">SUCCESS</code> if everything works as expected or <code class="language-kotlin">FAILURE</code> if the assertion method throws <code class="language-kotlin">AssertionFailedError</code>.</p>
</div>
