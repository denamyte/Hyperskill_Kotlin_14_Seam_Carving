<div class="step-text">
<p>You can declare a <a class="theory-lookup not-relevant" href="/learn/step/14661" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a variable is a storage for a value, which can be a string, a number, or something else. | Every variable has a name (or an identifier) to distinguish it from other variables. You can access a value by the name of the variable. Variables are one of the most often used elements in a program; therefore, it is important to understand how to use them. Before you can start using a variable, you must declare it. In Kotlin, there are two types of variables: immutable and mutable. An immutable variable, declared with the `val` keyword, is a read-only variable that cannot be changed after it has been initialized, meaning a value can be assigned once. On the other hand, a mutable variable, declared with the `var` keyword, can be changed or modified after it has been declared and initialized.">variable</a> by putting an equal sign followed by a value after its name:</p>
<pre><code class="language-kotlin">var a = "I love Hyperskill!"</code></pre>
<p>Creating a <code class="language-kotlin">String</code> object like this isn't a very resource- or time-consuming operation for the compiler. But creating instances of more complex classes can be much more expensive. In this topic, you will learn how to tackle this issue by delaying the creation of objects until they are needed using <strong><a class="theory-lookup not-relevant" href="/learn/step/14661" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, lazy initialization is a technique that allows you to delay the creation of an object until it is first referenced. | This is particularly useful for more complex objects that are expensive to create, as it saves resources and time by not creating objects that aren't required from the outset. Kotlin provides a special function called `lazy` that accepts a lambda and executes it only the first time the lazy property is accessed. Subsequent accesses will return the result of the initial execution, without re-evaluating the lambda.">lazy initialization</a></strong>.</p>
<h5 id="how-it-works">How it works</h5>
<p>Lazy initialization lets us create an object at the exact point when the first reference to it occurs.</p>
<p>This means that we don't need to waste time by immediately using our program's resources to allocate memory to objects that aren't required from the outset.</p>
<p>If we allow objects to be initialized when they're needed, we can save a lot of time by redistributing the allocation of resources over the life cycle of our program.</p>
<h5 id="implementation">Implementation</h5>
<p>This goal can be achieved in different ways in different languages and frameworks.</p>
<p>For example, the <a href="https://spring.io/projects/spring-framework" rel="noopener noreferrer nofollow" target="_blank">Spring backend framework</a>  has the special property <code class="language-kotlin">spring.main.lazy-initialization=true</code>. This can reduce an application's startup time by creating fewer components at the beginning. However, in the context of Spring, this feature has some disadvantages that are beyond the scope of our topic. </p>
<p>Let's see how to use lazy initialization without frameworks.</p>
<p>Kotlin has a special <code class="language-kotlin">lazy()</code> <a class="theory-lookup" href="/learn/step/4575" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a function is a sequence of instructions that performs a specific action, such as printing data to standard output or calculating a square root. | It is a named block of code that can be invoked from a program using its name followed by parentheses. If a function takes one or more arguments (input data), they should be passed in the parentheses. Functions can return a result that can be assigned to a variable. Some functions, like regular math functions, take arguments and produce a result.">function</a> that accepts a <a href="https://hyperskill.org/learn/step/6154" rel="noopener noreferrer nofollow" target="_blank">lambda</a>. The first call executes this lambda and remembers the result. Subsequent calls simply return this value.</p>
<p>You can see a simple example below:</p>
<pre><code class="language-kotlin">fun main() {
    val a: String by lazy {
        print("Variable a is initialized. ")
        "I love Hyperskill!"
    }

    println("Initializing a! ") // Initializing a!
    println(a) // Variable a is initialized. I love Hyperskill!
    println(a) // I love Hyperskill!
}</code></pre>
<p>So, why did we get this output? Before the value of <code class="language-kotlin">a</code> became <code class="language-kotlin">"I love Hyperskill!"</code>, the lambda body was called with <code class="language-kotlin">print()</code>. This all happened the first time we called <code class="language-kotlin">println(a)</code> â€” no sooner, no later. When we printed <code class="language-kotlin">a</code> again, no calculation occurred, so only <code class="language-kotlin">a</code>'s value was displayed.</p>
<p></p>
<div class="alert alert-primary"><p>When using lazy initialization in Kotlin, you must declare variables with the <code class="language-kotlin">val</code> <a class="theory-lookup" href="/learn/step/4362" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a keyword is a word that has a special meaning in the language and cannot be changed by the programmer. | It is used to define the structure and behavior of the code. Examples of keywords in Kotlin include `fun` (used to define a function), `var` (used to define a variable), and `if` (used to define a conditional statement). Keywords are reserved words in Kotlin and cannot be used as identifiers.">keyword</a> because the value can only be initialized once.</p></div>
<p></p>
<h5 id="synchronization-problems">Synchronization problems</h5>
<p>If your programs take advantage of multithreading, you need to know about the <code class="language-kotlin">lazy()</code> function's mode parameter. </p>
<ul><li><p><code class="language-kotlin">LazyThreadSafetyMode.SYNCHRONIZED</code> means that the value is only computed in one thread, and all threads will get the same value. It's the default option, so you can omit it if you wish:</p><pre><code class="language-kotlin">val a: String by lazy(LazyThreadSafetyMode.SYNCHRONIZED) {</code></pre></li></ul>
<ul><li><p><code class="language-kotlin">LazyThreadSafetyMode.PUBLICATION</code> specifies that the lambda can be called several times with an uninitialized lazy object value, but the value that is returned first will be used:</p><pre><code class="language-kotlin">val a: String by lazy(LazyThreadSafetyMode.PUBLICATION) {</code></pre></li></ul>
<ul><li><p><code class="language-kotlin">LazyThreadSafetyMode.NONE</code> means there's no synchronization at all, so if we call the variable from different threads, its value can't be uniquely defined. Using this option isn't recommended if your program allows a lazy object to be called for the first time from more than one thread:</p><pre><code class="language-kotlin">val a: String by lazy(LazyThreadSafetyMode.None) {</code></pre></li></ul>
<p>You may be wondering why the keyword <code class="language-kotlin">by</code> is used before <code class="language-kotlin">lazy</code>? Well, it's to do with <strong><a class="theory-lookup" href="/learn/step/21405" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a delegate is a design pattern that allows one object to delegate certain functionality or tasks to another object. | It is implemented using the `by` keyword. Delegation helps in solving complex problems by overriding methods in the delegate object. It is also used to build your own delegates by delegating property to another property or an anonymous object. It provides flexibility and modularity in code as it allows changing the behavior of an object without modifying its source code. It is considered a best practice to use standard delegates when possible, keep your delegated property focused, and avoid unnecessary delegation.">delegates</a></strong>. This is how we delegate the <a class="theory-lookup not-relevant" href="/learn/step/14661" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, an implementation refers to the concrete realization of an interface's abstract methods and properties in a class. | Interfaces provide a way to generalize code and keep it clean by stating expected functionality first, which classes implementing the interface must adhere to. Implementation in the context of object-oriented programming represents the concept of abstraction and encapsulation. When a class implements an interface, it guarantees to provide the functionality the interface promises. Delegation comes into play when a new class needs to implement the same interface, allowing for code reuse without copy-pasting the existing implementation.">implementation</a> of the corresponding <a class="theory-lookup not-relevant" href="/learn/step/14661" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a property represents data within an object and controls how this data is accessed and manipulated. | It is a mechanism to encapsulate data within our object and differs from a method, which performs a certain operation. A property holds state or data, while a method contains logic. Property overriding is a feature in Kotlin that allows you to modify the behavior or value of a property in a derived class, providing a new layer of flexibility. You can define a property in a base class and then override it in a derived class, extending the property just like you can inherit and extend methods in object-oriented programming. In Kotlin, properties take the place of fields seen in other languages, like Java, and have a strict type, which can be a standard type or a custom type, even the same class where the property is declared.">property</a> to a lambda. A detailed explanation about this is provided in the delegates topic.</p>
<h5 id="lateinit">lateinit</h5>
<p>Another <a href="https://kotlinlang.org/docs/properties.html#late-initialized-properties-and-variables" rel="noopener noreferrer nofollow" target="_blank">delayed initialization feature in Kotlin</a> that's worth mentioning is <code class="language-kotlin">lateinit</code>. This is a keyword rather than a function like <code class="language-kotlin">lazy()</code>.</p>
<p>Normally, if a class field's value isn't null, we should either initialize the property immediately or do it in the constructor. But there are often situations where, at the time we create an instance of a class, we can't initialize the property, and we don't want to make it nullable.</p>
<p>We can't use the following approach because the default value of the field must be initialized:</p>
<pre><code class="language-kotlin">var a: String
</code></pre>
<p>We could make <code class="language-kotlin">a</code> nullable, but we don't want it to be!</p>
<pre><code class="language-kotlin">var a: String? = null
</code></pre>
<p>Fortunately, <code class="language-kotlin">lateinit</code> can be used to solve this problem:</p>
<pre><code class="language-kotlin">lateinit var a: String

fun initA(a: String) {
    this.a = a
}</code></pre>
<p>This method allows us to set the value of <code class="language-kotlin">a</code> in the <code class="language-kotlin">initA()</code> function at a convenient point after the object has been created.</p>
<p>Note that <code class="language-kotlin">lateinit</code> variables must be declared with <code class="language-kotlin">var</code>, unlike those declared with <code class="language-kotlin">lazy()</code>.</p>
<p>We can also check whether the property has already been initialized. To see how this works, let's add a function to our class. As shown below, <code class="language-kotlin">isInitialized</code> can be called on the current object's field via <code class="language-kotlin">this::a</code>, returning either true or false:</p>
<pre><code class="language-kotlin">lateinit var a: String

fun initA(a: String) {
    this.a = a
}

fun doSmth() {
    if (::a.isInitialized)
        println("a is Initialized")
    else
        println("a isn't Initialized")
}</code></pre>
<p></p>
<div class="alert alert-warning"><p>If you try to access a property before it has been initialized, an error will be thrown:</p><p></p><p>Caused by: kotlin.UninitializedPropertyAccessException: <a class="theory-lookup not-relevant" href="/learn/step/14661" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, `lateinit` is a modifier used for declaring properties that will be initialized at a later point in time, but before they are used. | It is used for properties that we are certain will be initialized before they are accessed, but we don't know the exact value at the time of declaration. Unlike `var` or `val`, `lateinit` does not assign a default value to the property. It is commonly used for properties that are initialized in dependency injection or in the initialization block of a class. It is important to note that `lateinit` can only be used with mutable properties (i.e. variables declared with `var`) and not with immutable properties (i.e.">lateinit</a> property a has not been initialized</p></div>
<p> </p>
<p></p>
<h5 id="conclusion">Conclusion</h5>
<p>You're now familiar with lazy initialization. You understand why it's needed and how it can be applied. Although their usage is quite similar, you're aware of the differences between <code class="language-kotlin">lazy()</code> and <code class="language-kotlin">lateinit</code>. You also know about the <code class="language-kotlin">lazy()</code> <a class="theory-lookup not-relevant" href="/learn/step/14661" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, thread safety refers to the property of a program or system that ensures consistent and correct behavior when accessed by multiple threads, even when those threads access shared data or resources concurrently. | Classic collections like List, Set, and Map are not thread-safe, which means that concurrent access to these collections can result in unexpected behavior or errors. To achieve thread safety, Kotlin provides synchronized collections like CopyOnWriteArrayList and ConcurrentHashMap, which are designed to handle concurrent access and modifications. However, these collections can have a performance impact.">thread safety</a> modes.</p>
</div>