<div class="step-text">
<p>Kotlin is a language that adapts to your way of programming or code writing, which allows you to develop the code you want when you want. Kotlin offers mechanisms that help us create code that is easy to read and understand.</p>
<p>One of the most interesting mechanisms is the <a class="theory-lookup not-relevant" href="/learn/step/26464" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, infix notation is a mechanism that allows you to define and use functions without using parentheses or a dot. | It is often used in arithmetical and logical code, where the function name is placed between the argument and the name of the function itself serves as the operator. For example, in the expression 2 + 3, the + operator is an infix operator. To define an infix function, you must meet certain requirements and add the infix keyword to your function definition. Infix function calls have lower precedence than arithmetic operators or other elements.">infix notation</a>. It allows us to define and use functions without parentheses or dots.</p>
<h5 id="infix-notation">Infix notation</h5>
<p>The infix notation is used in arithmetical and logical code. It is characterized by the placement of operators between <a class="theory-lookup" href="/learn/step/26442" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, an operand is a value or variable that an operator is being applied to. | For example, in the expression 1 + 3, 1 and 3 are the operands and + is the operator. Operands can be either literals, variables, or more complex expressions. In Kotlin, there are five arithmetic operators: addition (+), subtraction (-), multiplication (*), division (/), and modulus (%). These operators are binary, meaning they take two operands. Operands are evaluated and the operator is applied according to a set of rules called operator precedence.">operands</a>: for example, 2 + 3, where "+" is the infix operator.</p>
<p>In infix notation, the function name is placed between the arguments and the name of the function itself is the operator. An example of such a function would be <code class="language-kotlin">add(2, 4)</code> in which the function <code class="language-kotlin">add</code> denotes addition ("add"): <code class="language-kotlin">add(2, 4)</code> = <code class="language-kotlin">2 add 4</code>.</p>
<p>To define an <a class="theory-lookup not-relevant" href="/learn/step/26464" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, an infix function is a function that can be called using infix notation, where the function name is placed between the argument and the function name itself acts as the operator. | To define an infix function, you need to meet certain requirements and add the infix keyword to your function definition. Infix functions are useful for improving the readability of your code or creating a domain-specific language (DSL). However, it is important to note that infix function calls have lower precedence than arithmetic operators or other elements defined in the language, such as type casts and certain operators. Additionally, infix functions always require both the receiver and the parameter to be specified, and you must use the `this` keyword to reference the current receiver.">infix function</a>, you must meet the following requirements.</p>
<ul>
<li>They must be member functions or extension functions.</li>
<li>They must have a single parameter.</li>
<li>The parameter must not accept variable number of arguments and must have no default value.</li>
</ul>
<p>To define your own functions with the infix notation, just add the <code class="language-kotlin">infix</code> keyword to your function definition.</p>
<pre><code class="language-kotlin">infix fun Int.add(x: Int): Int = this + x

fun main() {
    println(1.add(2)) // result is 3 as extension function
    println(1 add 2)  // result is 3 as infix function
}
</code></pre>
<h5 id="creating-infix-functions">Creating infix functions</h5>
<p>You can create infix functions whenever you want: for example, to improve the readability of your code or create a DSL (Domain Specific Language). But remember, infix function calls have lower <a class="theory-lookup" href="/learn/step/4515" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, precedence refers to the rule that determines the order of performing and grouping operations in an expression. | Operations with higher precedence are performed before those with lower precedence. For example, multiplication has higher precedence than addition, so if you have an expression like 2 + 3 * 4, the multiplication will be performed first, resulting in 14 + 3 = 17. Parentheses can be used to increase the priority of an operation or to make the code clearer. Precedence determines how other variables are grouped in the absence of parentheses. For example, for not, xor, and, or, the grouping of variables is as follows: you can use parentheses to change the order of execution. For instance, when writing a boolean expression that determines the possibility of going on a hike during the summer and in other seasons, a good programmer should understand not only arithmetic rules but also logical operations. This way, you can avoid hiking in bad weather. In this topic, we have discussed the four main Kotlin logical operators: (not), (exclusive or), (and), and (or).">precedence</a> than <a class="theory-lookup" href="/learn/step/26442" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, arithmetic operators are symbols used to perform mathematical operations such as addition, subtraction, multiplication, division, and modulo division. | These operators take two values or variables, also known as operands, as inputs and produce a single output. For example, in the expression 1 + 3, 1 and 3 are the operands, and + is the operator. Multiplication has a higher priority than addition or subtraction, meaning it is calculated first. Parentheses can be used to specify the order of execution and simplify the notation. For instance, the program below prints all digits of a number in reverse order using arithmetic operations to extract the digits. The divide operator in Kotlin is denoted by the forward slash (/). It performs division on two numbers and returns the quotient.">arithmetic operators</a> or other elements defined in the language, like <a class="theory-lookup not-relevant" href="/learn/step/26464" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, type casting is the process of converting an object from one data type to another. | It is used when working with objects of different types and performing operations that require a specific type. Kotlin, being a statically-typed language, has several features that make type checking and casting easy and safe to use. The `is` and `!is` operators in Kotlin are used for type checking. They allow developers to check if an object belongs to a particular data type. The `as` keyword is used for casting an object to a different type.">type casts</a> and the <code class="language-kotlin">rangeTo</code> operator.</p>
<pre><code class="language-kotlin">infix fun Int.add(x: Int): Int = this + x
fun main() {
    println(1 add 2 + 3)   // 6
    println(1 add (2 + 3)) // 6
    println(0..(1 add 3))  // 0..4
}</code></pre>
<p>On the other hand, an infix function's call precedence is higher than that of the boolean operators <code class="language-kotlin">&amp;&amp;</code> and <code class="language-kotlin">||</code>, <code class="language-kotlin">is</code>- and <code class="language-kotlin">in</code>-checks, and some other operators. </p>
<pre><code class="language-kotlin">infix fun Int.add(x: Int): Int = this + x
fun main() {
    println(1 and 2 xor 3 add 4) // 1 and 2 xor (3 add 4) -&gt; 7
    println(1 add 2 in 3..4)     // (1 add 2) in 3..4 -&gt; true
}</code></pre>
<p>Remember also that infix functions always require both the receiver and the parameter to be specified and that you must use <code class="language-kotlin">this</code> to <a class="theory-lookup not-relevant" href="/learn/step/26464" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a reference is a way to refer to a function or a constructor without immediately invoking it. | It allows for cleaner code, especially in the context of event handling, callbacks, and collection manipulation. There are four kinds of function references: reference to a function, reference by class, reference by object, and reference to a constructor. For example, a reference to a function can be created using the following declaration: `let`; this reference can then be invoked like a normal function, taking any necessary arguments.">reference</a> the current receiver.</p>
<pre><code class="language-kotlin">infix fun Int.add(x: Int): Int = this + x // this is the receiver
fun main() {
    println(2 + 3) // receiver is 2
}</code></pre>
<h5 id="standard-library-infix-functions">Standard Library Infix Functions</h5>
<p>In the Kotlin <a class="theory-lookup" href="/learn/step/33986" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a standard library is a fundamental part of the Kotlin programming language that is included with the language and provides essential functionality for working with the language. | It offers a robust set of tools to handle various programming tasks efficiently, and it is designed to work seamlessly with Kotlin's language features. The standard library includes functions, classes, and methods that provide pre-built functionality, which can be invoked or used in your code, saving you the time and effort of writing these functionalities from scratch. Examples of functionalities provided by the Kotlin standard library include handling complex math calculations like the sine and cosine of an angle. Standard libraries can be categorized into those that are included with the language and provide essential functionality, and third-party libraries that offer specialized or advanced features.">standard library</a>, we have many examples of functions used with the infix notation:</p>
<ul>
<li>Function <code class="language-kotlin">to()</code>: with <code class="language-kotlin">Pair&lt;A, B&gt;</code> and <code class="language-kotlin">Map&lt;T, V&gt;</code>.</li>
<li>Bitwise functions: <code class="language-kotlin">and()</code>, <code class="language-kotlin">or()</code>, <code class="language-kotlin">shl()</code>, <code class="language-kotlin">shr()</code>, <code class="language-kotlin">ushr()</code>, and <code class="language-kotlin">xor()</code>.</li>
<li><code class="language-kotlin">Boolean</code> class methods: <code class="language-kotlin">and()</code>, <code class="language-kotlin">or()</code>, and <code class="language-kotlin">xor()</code>. </li>
<li><code class="language-kotlin">String</code> class methods: <code class="language-kotlin">match</code> and <code class="language-kotlin">zip</code> functions.</li>
</ul>
<pre><code class="language-kotlin">fun main() {
    println("Hi" to "Kotlin")                          // ("Hi", "Kotlin")
    println(0x123456 shr 16)                           // 18
    println(true and false or true xor false)          // true
    println("Hi, Kotlin" matches ".*Kotlin".toRegex()) // true
}</code></pre>
<p><strong style="font-size: 1.17em; text-align: inherit;">Conclusion</strong></p>
<p>Infix functions are a powerful tool for making our code more readable and maintainable. Using them, you must take into account the indicated requirements as well as the order of precedence of operators. Infix notation will help you take your code to another level of quality and expand the possibilities of code writing.</p>
<p>Now is the time to do some tasks to check what you have learned. Are you ready?</p>
</div>