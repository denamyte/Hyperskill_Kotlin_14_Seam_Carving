<div class="step-text">
<p>Overriding properties is a vital feature provided by Kotlin. It allows us to take already defined properties and modify their behavior in subclasses. This means that we can define a property in a <a class="theory-lookup not-relevant" href="/learn/step/30920" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a base class is a class that forms the foundation for other classes, also known as derived classes. | It can have multiple constructors, including a primary constructor and secondary ones. A derived class can initialize the base class by implementing one or more of its constructors. The base class can also define common behavior for derived classes through abstract methods, which are methods without implementation that must be overridden in derived classes.">base class</a> and then override it in a derived class. Just like we inherit and extend methods in object-oriented programming, we can also extend properties in Kotlin.</p>
<h5 id="basics-of-property-and-method-overriding">Basics of property and method overriding</h5>
<p>In Kotlin, properties take the place of fields we typically see in other languages, like Java. Properties provide us with a mechanism to encapsulate data within our objects and control how this data is accessed and manipulated. Property overriding allows us to change the behavior or value of a property in a derived class, providing a new layer of flexibility. For <a class="theory-lookup not-relevant" href="/learn/step/30920" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, an instance refers to an object or an instance of a class that is created during runtime. | It is a subtype of every known type in Kotlin, meaning it can represent a value of any type in terms of type checking. This is particularly useful in situations where a function demands a return type, but it is impossible to return a value, such as when calculating a percentage if the value is zero. In such cases, a function that returns `Instance` can be used. The concept of instance is also related to threading, where only one thread can execute code in a synchronized method of a particular instance. This means that different threads can execute methods of different objects at the same time, a concept that can be summarized as one thread per instance.">instance</a>, if we have a property <code class="language-kotlin">speed</code> in a <code class="language-kotlin">Vehicle</code> class, we could override it in a <code class="language-kotlin">Car</code> class to be a specific value.</p>
<p>The <a class="theory-lookup not-relevant" href="/learn/step/30920" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a keyword is a word that has a special meaning in the language and cannot be changed by the programmer. | It is used to define the structure and behavior of the code. Examples of keywords in Kotlin include `fun` (used to define a function), `var` (used to define a variable), and `if` (used to define a conditional statement). Keywords are reserved words in Kotlin and cannot be used as identifiers.">keyword</a> <code class="language-kotlin">override</code> is used to override both properties and methods in subclasses. In Kotlin, properties and methods operate differently. A method is a function that performs a certain operation, whereas a property represents data. This difference is essential because methods often contain logic, while properties contain states or data. In our <code class="language-kotlin">Vehicle</code> and <code class="language-kotlin">Car</code> example, a method might be <code class="language-kotlin">accelerate()</code>, which would increase speed, while <code class="language-kotlin">speed</code> itself is a property.</p>
<h5 id="property-overriding-in-practice">Property overriding in practice</h5>
<p>Let's delve into some code to demonstrate how overriding works:</p>
<pre><code class="language-kotlin">open class Vehicle {
    open val speed: Int = 0
}

class Car: Vehicle() {
    override val speed: Int = 60
}

fun main() {
    val car = Car()
    println(car.speed) // Output: 60
}

</code></pre>
<p>In the above example, we have a property <code class="language-kotlin">speed</code> in the base class <code class="language-kotlin">Vehicle</code>, which we then override in the subclass <code class="language-kotlin">Car</code>. This effectively means that all <code class="language-kotlin">Car</code> objects have a <code class="language-kotlin">speed</code> of 60 by default, unlike the generic <code class="language-kotlin">Vehicle</code>, which has a <code class="language-kotlin">speed</code> of 0.</p>
<h5 id="overriding-properties-using-getters-and-setters">Overriding properties using getters and setters</h5>
<p>In Kotlin, properties come with built-in getter and setter functions. These control how properties are accessed and modified. When overriding properties, we can also modify the getter and setter functions.</p>
<p>For example:</p>
<pre><code class="language-kotlin">open class Vehicle {
    open val speed: Int 
        get() = 0
}

class Car: Vehicle() {
    override val speed: Int 
        get() = 60
}
</code></pre>
<p>In this example, instead of merely overriding the property, we override the getter for the <code class="language-kotlin">speed</code> property. Whenever the <code class="language-kotlin">speed</code> of a <code class="language-kotlin">Car</code> object is accessed, it will always return 60, regardless of any modifications.</p>
<h5 id="overriding-abstract-properties">Overriding abstract properties</h5>
<p><a class="theory-lookup not-relevant" href="/learn/step/30920" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, an abstract class is a blueprint for creating other classes. | It cannot be instantiated directly and serves as a base class for other classes. Abstract classes can have constructor functions to initialize their properties and can contain both abstract and non-abstract members (properties and methods). Abstract members are declared without an implementation and must be overridden by any class that extends the abstract class. Non-abstract members, on the other hand, can provide a common implementation that can be inherited by subclasses. If a class extends an abstract class, it must provide an implementation for all the abstract members declared in the abstract class.">Abstract</a> properties are a little different. They're declared in an abstract class without an initializer, and they must be overridden in any non-abstract subclass.</p>
<pre><code class="language-kotlin">abstract class Vehicle {
    abstract val speed: Int
}

class Car: Vehicle() {
    override val speed: Int = 60
}
</code></pre>
<p>In this case, <code class="language-kotlin">Vehicle</code> doesn't specify any speed: each specific type of <code class="language-kotlin">Vehicle</code> must define its own <code class="language-kotlin">speed</code>. <code class="language-kotlin">Car</code> does so by setting <code class="language-kotlin">speed</code> to 60.</p>
<h5 id="conclusion">Conclusion</h5>
<p>In conclusion, property overriding is a powerful tool in Kotlin that allows us to create more flexible and <a class="theory-lookup not-relevant" href="/learn/step/30920" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, reusable code refers to the ability to create and implement code that can be utilized in multiple contexts or situations within a program. | This is often achieved through the use of generics and the any keyword, which allow for the creation of reusable functions and classes that can operate on different data types. By shifting type checking from runtime to compile-time, generic code promotes code reusability and can help prevent the creation of redundant code. Additionally, using immutable variables can further enhance code readability and reusability.">reusable code</a>. It enhances the principles of inheritance by allowing us to extend not just methods, but also properties. It's practice time, so go ahead!</p>
</div>