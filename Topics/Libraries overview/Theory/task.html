<div class="step-text">
<p>You have certainly come across the term <strong>library</strong> several times in your coding journey with Kotlin (or even another programming language). But what options are available to you in this realm of libraries? And how should you use them in a proper way without seeing any linting error screaming at your face, or even worse—introducing bugs into your code?</p>
<p>In this topic, you will get answers to all those questions, and you will be able to navigate your way in the uncharted territories of the vast landscape of libraries without feeling lost. Let's get started on your journey to becoming a true librarian.</p>
<h5 id="understanding-libraries">Understanding libraries</h5>
<p>We've discussed what libraries are from a general point of view in a separate <a href="https://hyperskill.org/learn/step/8504" rel="noopener noreferrer nofollow" target="_blank">topic</a>, but a small reminder never hurts. So, in the case of Kotlin, we can say that libraries are used to extend the language's capabilities and simplify the coding process. They provide pre-built <a class="theory-lookup not-relevant" href="/learn/step/33986" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, functionality refers to a specific feature or action that a software program can perform. | It is often achieved through the use of functions, which are sequences of instructions that can be invoked by the program to perform a specific task. In the context of functional programming, functionality is broken down into smaller, simpler functions that can process and transform data in a declarative way without changing the original data. This allows for functional decomposition, where a complex system is broken down into smaller, easier-to-manage components, also known as functions or modules.">functionalities</a> like functions, classes, and methods, which can be invoked or used in your code, saving you the time and effort of writing these functionalities from scratch. For example, the Kotlin <a class="theory-lookup not-relevant" href="/learn/step/33986" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a standard library is a fundamental part of the Kotlin programming language that is included with the language and provides essential functionality for working with the language. | It offers a robust set of tools to handle various programming tasks efficiently, and it is designed to work seamlessly with Kotlin's language features. The standard library includes functions, classes, and methods that provide pre-built functionality, which can be invoked or used in your code, saving you the time and effort of writing these functionalities from scratch. Examples of functionalities provided by the Kotlin standard library include handling complex math calculations like the sine and cosine of an angle. Standard libraries can be categorized into those that are included with the language and provide essential functionality, and third-party libraries that offer specialized or advanced features.">standard library</a> provides functions to handle complex math calculations like the sine and cosine of an angle.</p>
<p>Similar to other languages' libraries, Kotlin libraries also can be categorized into two types: <strong>standard libraries</strong> and <strong><a class="theory-lookup not-relevant" href="/learn/step/33986" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a third-party library is a collection of pre-built functionality that is not included in the standard library, developed and maintained by either JetBrains or other developers and organizations. | These libraries provide specialized or advanced features that are not covered by the standard library, such as network request handling, database operations, image processing, or machine learning capabilities. Using third-party libraries can significantly boost productivity and enhance the capability of your application. However, it's important to follow best practices, such as understanding their functionality, integrating them correctly into your project, and managing their dependencies effectively, particularly in large projects.">third-party libraries</a></strong>. We will explore each type later and see what features they provide.</p>
<p>Kotlin offers many advantages when you use its libraries. Here are some of the main ones:</p>
<ol>
<li><strong>Efficiency</strong>. Libraries provide pre-written code that can be used to perform common tasks, saving developers a significant amount of time and effort. </li>
<li><strong>Quality</strong>. Libraries often undergo rigorous testing and quality assurance processes, which means the code they provide is generally reliable and bug-free.</li>
<li><strong>Simplicity</strong>. Libraries abstract away complex tasks, providing simple interfaces that developers can use without needing to understand the underlying complexity.</li>
<li><strong>Community support</strong>. Popular libraries often have a large community of users who can provide support and assistance. This can be particularly helpful when you encounter problems or need help understanding how to use the library.</li>
</ol>
<p>Let's move now to real examples and explore the amazing world of Kotlin libraries.</p>
<h5 id="kotlin-standard-libraries">Kotlin standard libraries</h5>
<p>Some of the recurring things you need to do in your daily life of coding are operations on collections or strings. Imagine every time you need to split a string into multiple sub-strings using a specified delimiter, you have to write that <a class="theory-lookup" href="/learn/step/6621" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, an extension function is a function that can be called on an existing class as if it were a member of that class, but is actually defined outside of the class. | It allows developers to add new functionality to existing classes without modifying the original class code. Extension functions take the receiver object (the class they are extending) as the first argument, which is implicitly passed. They can take arguments and return values like regular functions. If a class has both a member function and an extension function with the same name and signature, the member function will take precedence.">extension function</a> from scratch (maybe you will give it a fancier name, but I think we agree that's not what will make your coding life easier). What if this extension function already exists and is easy to reach (like a snap of fingers) and well-written so it can encompass many possible splitting operations, wouldn't that be great? Well, you are in luck because that's what Kotlin standard libraries exist for.</p>
<p><strong>Kotlin standard libraries</strong> are a fundamental part of the Kotlin programming language (all you need is a snap! Well... mostly). They are maintained by <strong>JetBrains</strong> (the company behind Kotlin). The standard libraries are included with the Kotlin language and provide essential functionality for working with the language. These libraries are designed to work seamlessly with Kotlin's language features, offering developers a robust set of tools to handle various programming tasks efficiently and effectively. They include functions for handling collections, strings, math calculations, and more.</p>
<p>Let's explore some of the main features and functionalities that Kotlin standard libraries offer:</p>
<p><strong>1) Collection functions</strong>. The standard libraries provide a comprehensive set of functions for working with collections such as lists, sets, and maps. These include functions like:</p>
<ul>
<li><code class="language-kotlin">map</code>: transforms the collection based on a given function.</li>
<li><code class="language-kotlin">filter</code>: filters the collection based on a given condition.</li>
<li><code class="language-kotlin">reduce</code>: combines the elements of the collection in a sequential manner using a specified function.</li>
</ul>
<p>To use these functions in your code, you just have to call them right away (remember: snap of fingers), and here is an example:</p>
<pre><code class="language-kotlin">val numbers = listOf(1, 2, 3, 4, 5)
val squaredNumbers = numbers.map { it * it }       // [1, 4, 9, 16, 25]
val evenNumbers = numbers.filter { it % 2 == 0 }   // [2, 4]
val product = numbers.reduce { acc, i -&gt; acc * i } // 120
</code></pre>
<p><strong>2) String functions</strong>.<strong> </strong>The standard libraries offer a variety of functions to manipulate and process strings. These include functions like:</p>
<ul>
<li><code class="language-kotlin">split</code>: splits the string into a list of strings based on a specified delimiter.</li>
<li><code class="language-kotlin">substring</code>: returns a subsequence of the string based on the specified range.</li>
</ul>
<p>Here is an example of how to use them:</p>
<pre><code class="language-kotlin">val str = "Hello, Kotlin!"
val words = str.split(", ")         // ["Hello", "Kotlin!"]
val substring = str.substring(0, 5) // "Hello"</code></pre>
<p><strong>3) Math functions</strong>. The standard libraries also include various math functions like:</p>
<ul>
<li><code class="language-kotlin">max</code>: returns the maximum of two numbers.</li>
<li><code class="language-kotlin">min</code>: returns the minimum of two numbers.</li>
<li><code class="language-kotlin">abs</code>: returns the absolute value of a number.</li>
</ul>
<p>Because these functions are declared by the same name in other standard libraries, we must import them explicitly on top of our code:</p>
<pre><code class="language-kotlin">import kotlin.math.max
import kotlin.math.min
import kotlin.math.abs</code></pre>
<p>Alternatively, we can use the <code class="language-kotlin">*</code> symbol to import all functions in the same package in one line:</p>
<pre><code class="language-kotlin">import kotlin.math.*</code></pre>
<p>The <code class="language-kotlin">*</code> symbol imports all the accessible contents of the <code class="language-kotlin">kotlin.math</code> package into the current file. This means that you can use all the functions and properties from the <code class="language-kotlin">kotlin.math</code> package without having to qualify them with the package name.</p>
<p>Here is a complete example:</p>
<pre><code class="language-kotlin">import kotlin.math.*

val max = max(10, 20) // 20
val min = min(10, 20) // 10
val abs = abs(-10)    // 10</code></pre>
<p></p>
<div class="alert alert-primary"> Sometimes, when you want to use a function of a standard library, the IDE will ask you to import the function explicitly to your code. This happens because the same function is declared in other standard or third-party libraries that are included in your project.</div>
<p><strong>4) Random methods</strong>. The standard libraries provide a suite of methods for generating random numbers through the <code class="language-kotlin">kotlin.random.Random</code> class.</p>
<p>Let's consider a use case where you want to generate a random number within a range, say, for a dice roll in a game:</p>
<pre><code class="language-kotlin">import kotlin.random.Random

fun main() {
    val diceRoll = Random.nextInt(1, 7)
    println("You rolled: $diceRoll")
}</code></pre>
<p>In this example, <code class="language-kotlin">Random.nextInt(1, 7)</code> generates a random integer between $1$ and $6$ (inclusive), simulating a dice roll.</p>
<h5 id="third-party-libraries">Third-party libraries</h5>
<p>While the Kotlin standard libraries are core libraries that are included with the language and provide essential functionalities for working with it, <strong>third-party libraries</strong> are libraries that provide specialized or advanced features that are not covered by the standard libraries. These features can range from those that simplify complex tasks, such as handling network requests (like <strong>Retrofit</strong>) or database operations (like <strong>Exposed</strong>), to those that provide completely new functionalities, such as image processing (like <strong>COIL</strong>) or machine learning capabilities (like <strong>Weka</strong> or <strong>Deeplearning4j</strong>). Third-party libraries might be developed and maintained by JetBrains themselves to provide additional functionalities outside the essential ones (like <strong>Kotlinx</strong>) or by other developers and organizations.</p>
<p>Let's take a look at some popular third-party libraries that can be used in Kotlin and at their key features:</p>
<p></p>
<div class="alert alert-warning">Throughout this section, remember that you don't need to understand every example in detail. The purpose here is to provide a broad overview. Each of the following libraries is discussed in more depth in dedicated topics.</div>
<p><strong>1) Kotlinx libraries</strong>.<strong> </strong>The <code class="language-kotlin">kotlinx</code> libraries are additional libraries developed by JetBrains, which provide support for various features and functionalities, such as coroutines, serialization, and date/time handling, among others. These libraries are not included with the Kotlin language by default and must be added as <strong>dependencies</strong> to your project if you want to use them (more on that later).</p>
<ul>
<li><code class="language-kotlin">kotlinx.coroutines</code>: This is a library for managing concurrency. It introduces the concept of <strong>coroutines</strong>, which are light-weight threads, in Kotlin. This makes it easier to write asynchronous and non-blocking code.</li>
</ul>
<p>Here is an example of how to use the <code class="language-kotlin">runBlocking</code> function defined in the <code class="language-kotlin">kotlinx.coroutines</code> library:</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking { 
    launch { 
        delay(1000L) 
        println("World!") 
    }
    print("Hello, ")
}</code></pre>
<p>In this example, <code class="language-kotlin">runBlocking</code> is a <a class="theory-lookup" href="/learn/step/13749" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a coroutine builder is a function that allows you to create and manage coroutines, which are lightweight threads that can be used to execute asynchronous code. | Coroutine builders, such as `launch` and `runBlocking`, bridge the gap between regular and suspending functions, enabling you to run suspending code without blocking the execution of the rest of your code. When you use a coroutine builder, you can control the launched coroutine, check its status, and wait for its result using the `.join()` method. Additionally, when the resulting `Deferred` object is cancelled, the running coroutine is also cancelled. By default, the coroutine is immediately scheduled for execution, but you can specify other options using parameters.">coroutine builder</a> that blocks the main thread. Inside it, we launch a new coroutine without blocking the current thread. This coroutine waits for 1 second (without blocking, so "Hello, " will be printed first) and then prints "World!"</p>
<ul>
<li><code class="language-kotlin">kotlinx.serialization</code>: This library converts objects to strings or other formats (serialization) and back (deserialization). It supports various serialization formats, including JSON, CBOR, and Protobuf.</li>
</ul>
<pre><code class="language-kotlin">import kotlinx.serialization.*
import kotlinx.serialization.json.*

@Serializable
data class Person(val name: String, val age: Int)

fun main() {
    val person = Person("Omar", 20)
    val jsonString = Json.encodeToString(person)
    println(jsonString) // Outputs: {"name":"Omar","age":20}

    val person2 = Json.decodeFromString&lt;Person&gt;(jsonString)
    println(person2)   // Outputs: Person(name=Omar, age=20)
}</code></pre>
<p>In this example, we define a <code class="language-kotlin">Person</code> <a class="theory-lookup" href="/learn/step/8526" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a data class is a special type of class that automatically provides implementations of several common methods, such as `equals()`, `hashCode()`, and `toString()`, based on the properties of the class. | This is done using the `data` keyword before the class definition. This simplifies the code required for standard operations and allows for easier comparison of objects based on their properties. Additionally, data classes automatically provide a `copy()` function, which creates a shallow copy of the object, and `componentN()` functions, which can be used for destructuring declarations.">data class</a> and use <code class="language-kotlin">kotlinx.serialization</code> to convert an instance of <code class="language-kotlin">Person</code> to a JSON string and back.</p>
<ul>
<li><code class="language-kotlin">kotlinx.datetime</code>: This library provides a more modern and intuitive API for date and time manipulation than the standard Java <code class="language-kotlin">Date</code> and <code class="language-kotlin">Calendar</code> classes.</li>
</ul>
<pre><code class="language-kotlin">import kotlinx.datetime.*

fun main() {
    val currentMoment = Clock.System.now()
    println(currentMoment) // Outputs the current moment in ISO-8601 format

    val today = LocalDate.todayAt(TimeZone.currentSystemDefault())
    println(today) // Outputs today's date
}</code></pre>
<p><strong>2) JUnit</strong>. This is a popular testing framework for Java, and it's fully compatible with Kotlin. It provides annotations to identify <a class="theory-lookup" href="/learn/step/25384" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a test method is a function inside a test class that is annotated with the `@Test` annotation. | This annotation indicates to the JUnit framework that the method is a unit test method. Test functions should have clear and descriptive names that make it easy to understand their purpose and identify the source of a failure or bug when running multiple tests. A common naming convention is `methodName_input_expectedBehavior`, which clearly communicates the purpose of the test, including the method being tested, the input or condition the method is being called with, and the expected outcome. JUnit provides a variety of methods for testing different conditions. For example, you can test if the arguments are equal, if a value is null, if the argument is an instance of a certain class, if the argument is not null, or if the argument throws a certain exception. These methods have overloads that accept a message of the type `String`, which is displayed if the test fails. JUnit also provides a convenient tool for writing effective and concise tests called parameterized tests. Instead of multiple test methods, you can have a single method denoted by `@ParameterizedTest`, which takes parameters so that you can supply different arguments to it. This allows you to reuse your code efficiently and improve the readability of your tests. JUnit has many options to set up argument sources for your tests, including `@ValueSource`, `@NullSource`, `@EmptySource`, and `@CsvSource`, among others.">test methods</a> and contains <a class="theory-lookup" href="/learn/step/24358" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, an assertion is a mechanism used to monitor the program state and ensure that certain conditions are met. | It works by terminating the program in a fail-fast manner when it encounters a failure, which helps to quickly identify and address issues during the development stage. Assertions can be used to enforce invariants, as well as to check method preconditions and postconditions. This allows developers to ensure that their code is functioning properly and to detect and fix bugs efficiently.">assertions</a> for testing expected results.</p>
<p>Here's an example of a simple JUnit test:</p>
<pre><code class="language-kotlin">import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

class MyTest {

    @Test
    fun additionTest() {
        val sum = 2 + 2
        assertEquals(4, sum)
    }
}
</code></pre>
<p>In this example, we use the <code class="language-kotlin">@Test</code> annotation to define a test method. Inside the method, we're using the <code class="language-kotlin">assertEquals</code> function to assert that the sum of $2$ and $2$ is indeed $4$.</p>
<p><strong>3) Ktor</strong>.<strong> </strong>This is an official framework (built and maintained by JetBrains) for building asynchronous <a class="theory-lookup" href="/learn/step/28029" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a server is a program that listens for incoming requests from clients on a specific port. | It waits for new requests and either accepts or denies them. If a request is accepted, the server creates a socket for interaction with the client. Both the client and server can send data to each other using their respective sockets. A server typically interacts with multiple clients and the duration of the interaction depends on the application. It's worth noting that both the client and server programs can be located on the same computer or on different machines connected through a network.">servers</a> and clients in connected systems. It's highly modular, allowing you to include only the features you need.</p>
<p>Here is a simple example of a <code class="language-kotlin">Ktor</code> server that responds with <code class="language-kotlin">"Hello, World!"</code> to every request:</p>
<pre><code class="language-kotlin">import io.ktor.application.*
import io.ktor.response.*
import io.ktor.routing.*
import io.ktor.server.engine.*
import io.ktor.server.netty.*

fun main() {
    embeddedServer(Netty, port = 8080) {
        routing {
            get("/") {
                call.respondText("Hello, World!")
            }
        }
    }.start(wait = true)
}</code></pre>
<p>In this example, the server is started on port <code class="language-kotlin">8080</code> and waits for incoming connections.</p>
<p><strong>4) Retrofit</strong>. This is a type-safe HTTP client for Android and Java. It allows you to turn your HTTP API into a Kotlin interface by using annotations to describe the HTTP requests.</p>
<p>To use Retrofit in your code, first, define an interface for your API. Here is an example:</p>
<pre><code class="language-kotlin">interface MyApi {

    @GET("users/{user}/repos")
    suspend fun listRepos(@Path("user") user: String): List&lt;Repo&gt;
}
</code></pre>
<p>Then, create a Retrofit instance and use it to create an implementation of your API interface:</p>
<pre><code class="language-kotlin">val retrofit = Retrofit.Builder()
    .baseUrl("https://api.github.com/")
    .build()

val api = retrofit.create(MyApi::class.java)

val repos = api.listRepos("octocat")</code></pre>
<p>In this example, an API interface is defined with Retrofit annotations, and then a Retrofit <a class="theory-lookup not-relevant" href="/learn/step/33986" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, an instance refers to an object or an instance of a class that is created during runtime. | It is a subtype of every known type in Kotlin, meaning it can represent a value of any type in terms of type checking. This is particularly useful in situations where a function demands a return type, but it is impossible to return a value, such as when calculating a percentage if the value is zero. In such cases, a function that returns `Instance` can be used. The concept of instance is also related to threading, where only one thread can execute code in a synchronized method of a particular instance. This means that different threads can execute methods of different objects at the same time, a concept that can be summarized as one thread per instance.">instance</a> is created to build an implementation of this API interface. This setup allows for easy and safe HTTP communication.</p>
<p><strong>5) Exposed</strong>. This is a lightweight SQL library for Kotlin created by the JetBrains team. It provides a typesafe SQL interface allowing you to work with databases in a more Kotlin-idiomatic way.</p>
<p>Here's an example of how you might use Exposed to query a database:</p>
<pre><code class="language-kotlin">Database.connect("jdbc:h2:mem:test;DB_CLOSE_DELAY=-1;", driver = "org.h2.Driver")

transaction {
    SchemaUtils.create(Users)

    Users.insert {
        it[name] = "John"
        it[age] = 27
    }

    Users.select { Users.age greaterEq 27 }.forEach {
        println("${it[Users.name]} is ${it[Users.age]} years old")
    }
}</code></pre>
<p>In this example, Exposed is used to connect to a database, create a table, insert data, and then query the data.</p>
<p>Third-party libraries won't work in your code just by importing the right packages. Your build tool (like Gradle) needs to know where to find these libraries. This is done by specifying dependencies (and sometimes plugins) in your build configuration. Let's see next how to do that.</p>
<h5 id="integrating-libraries-in-a-project">Integrating libraries in a project</h5>
<p>Once you've chosen the libraries that best suit your project's needs, in order for you to use their functions and classes in your code, you need to integrate them into your project. This process involves specifying dependencies and importing packages. In this section, we will guide you through this process and provide some sample code for demonstration.</p>
<p></p>
<div class="alert alert-warning">In this topic, we will only discuss working with Gradle as the chosen building tool for your project.</div>
<p>The process of integrating a library into your project typically involves the following steps:</p>
<p><strong>1) Add the library as a dependency</strong>. Before you can use a library, you need to add it as a dependency to your project. This is usually done in <code class="language-kotlin">build.gradle</code> (or <code class="language-kotlin">build.gradle.kts</code>). Here's an example of how you might add a dependency for the <code class="language-kotlin">kotlinx.coroutines</code> library:</p>
<pre><code class="language-kotlin">// using Kotlin DSL
dependencies {
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.5.1")
}

// using Groovy DSL
dependencies {
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.5.1'
}</code></pre>
<p><strong>2) Specify the plugin (if required)</strong>. Some libraries require you to specify a plugin in your <code class="language-kotlin">build.gradle(.kts)</code> file. This is usually mentioned in the library's documentation. Here is an example of how you might specify a plugin for the <code class="language-kotlin">kotlinx.serialization</code> library:</p>
<pre><code class="language-kotlin">// using Kotlin DSL
plugins {
    id("org.jetbrains.kotlin.plugin.serialization") version "1.7.20"
}

// using Groovy DSL
plugins {
    id 'org.jetbrains.kotlin.plugin.serialization' version '1.7.20'
}</code></pre>
<p><strong>3) Sync your project</strong>.<strong> </strong>After adding the library as a dependency and specifying the plugin (if required), you need to sync your project. In IntelliJ IDEA, this can be done by clicking on the "Reload all Gradle projects" button in the Gradle tool window or by using the "Reload All from Disk" option in the File menu.</p>
<p><strong>4) Import the library in your code</strong>. Once the library is added to <code class="language-kotlin">build.gradle(.kts)</code> and your project is synced, you can import the library in your code using the <code class="language-kotlin">import</code> keyword. For example:</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*</code></pre>
<p></p>
<div class="alert alert-primary">This must be done at the top of your code.</div>
<p><strong>5) Use the library's functions and classes</strong>. After importing the library, you can use its functions and classes in your code. For example, you can launch a coroutine using the <code class="language-kotlin">launch</code> function from the <code class="language-kotlin">kotlinx.coroutines</code> library:</p>
<pre><code class="language-kotlin">fun main() = runBlocking {
    launch {
        // some code here
    }
}</code></pre>
<p>Remember, the process of integrating a library can vary slightly depending on the build system you're using (like Gradle or Maven), the IDE (like IntelliJ IDEA or Android Studio), and the library itself. Always refer to the official documentation of the library for the most accurate instructions. Here are the links for documentation of some popular libraries:</p>
<ul>
<li><a href="https://github.com/Kotlin/kotlinx-datetime#using-in-your-projects" rel="noopener noreferrer nofollow" target="_blank">Kotlinx.datetime</a></li>
<li><a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master#using-in-your-projects" rel="noopener noreferrer nofollow" target="_blank">Kotlinx.coroutines</a></li>
<li><a href="https://github.com/Kotlin/kotlinx.serialization#setup" rel="noopener noreferrer nofollow" target="_blank">Kotlinx.serialization</a></li>
<li><a href="https://github.com/ktorio/ktor#readme" rel="noopener noreferrer nofollow" target="_blank">Ktor</a></li>
<li><a href="https://github.com/JetBrains/Exposed#dependencies" rel="noopener noreferrer nofollow" target="_blank">Exposed</a></li>
<li><a href="https://search.maven.org/artifact/org.junit.jupiter/junit-jupiter" rel="noopener noreferrer nofollow" target="_blank">JUnit</a></li>
<li><a href="https://square.github.io/retrofit/#download" rel="noopener noreferrer nofollow" target="_blank">Retrofit</a></li>
</ul>
<p>Managing library dependencies can be challenging, especially in large projects. It will be helpful to follow these tips:</p>
<ul>
<li><strong>Use a dependency management tool</strong>. Tools like Gradle or Maven can automatically handle downloading and updating libraries, resolving dependencies, and more.</li>
<li><strong>Specify versions explicitly</strong>. When adding a library as a dependency, it's usually a good idea to specify the version explicitly. This can help avoid unexpected changes when the library is updated.</li>
<li><strong>Understand transitive dependencies</strong>. If you include a library that depends on other libraries, those are included in your project as well. These are called <strong>transitive dependencies</strong>. Be aware of them, as they can impact the size and performance of your application.</li>
</ul>
<h5 id="interoperability-with-java-libraries">Interoperability with Java libraries</h5>
<p>One of the key strengths of Kotlin is its <strong>seamless <a class="theory-lookup not-relevant" href="/learn/step/33986" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, interoperability refers to the ability of the Kotlin programming language to work seamlessly with existing Java libraries and frameworks. | This is made possible by the fact that both Kotlin and Java compile down to the same bytecode, which runs on the Java Virtual Machine (JVM). At the bytecode level, Kotlin classes and Java classes are indistinguishable from each other. This interoperability allows Kotlin developers to leverage the vast ecosystem of existing Java libraries, thus enhancing the capability of their Kotlin applications. For example, they can use Java's standard library, which offers a wide range of utility and functions, including APIs for HTTP methods such as GET, POST, PUT, and DELETE. These methods are commonly used in modern web development for building scalable and interoperable APIs. Moreover, Kotlin's interoperability with Java enables the use of RESTful services, which are web-based architectural styles for designing networked applications. RESTful services use standard HTTP methods to enable communication between different systems over the internet. They allow clients, such as web browsers or mobile apps, to request and manipulate data resources on a server in a stateless manner. JSON and XML are commonly used with RESTful services to facilitate data interchange within these services.">interoperability</a> with Java</strong>. Java has been around for a long time and has a vast ecosystem of libraries for virtually every programming need. When Kotlin was designed, one of its primary goals was to be <strong><a class="theory-lookup not-relevant" href="/learn/step/33986" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, fully interoperable refers to the seamless compatibility between Kotlin and Java, allowing developers to use Java libraries in a Kotlin project without any issues. | This interoperability is made possible because both Kotlin and Java compile down to the same bytecode that runs on the Java Virtual Machine (JVM). As a result, at the bytecode level, Kotlin classes and Java classes are indistinguishable from each other. This feature enables Kotlin developers to leverage the vast ecosystem of existing Java libraries, thereby enhancing the capabilities of their Kotlin application.">fully interoperable</a></strong> with Java. This means that any code you write in Java can be used in Kotlin and vice versa, therefore you can use Java libraries in your Kotlin projects without any issues. This interoperability allows Kotlin developers to leverage the vast ecosystem of existing Java libraries, thus enhancing the capabilities of their Kotlin applications.</p>
<p>Kotlin's <em>Java</em> interoperability is made possible by the fact that <strong>both Kotlin and Java compile down to the same bytecode</strong>, which runs on the Java Virtual Machine (JVM). This means that at the bytecode level, Kotlin classes and Java classes are indistinguishable from each other.</p>
<p>Much like the Kotlin standard library, Java also has its standard library, which<em> </em>offers tons of utilities and functions. For example, it offers APIs for:</p>
<ul>
<li><strong>Data structures </strong>like <code class="language-kotlin">ArrayList</code> and <code class="language-kotlin">HashMap</code> classes in the <code class="language-kotlin">java.util</code> package.</li>
<li><strong>Date and time manipulation </strong>like the <code class="language-kotlin">LocalDate</code>, <code class="language-kotlin">LocalTime</code>, and <code class="language-kotlin">LocalDateTime</code> classes in the <code class="language-kotlin">java.time</code> package.</li>
<li><strong>Network programming</strong> provided by the <code class="language-kotlin">java.net</code> package, which includes classes for network programming.</li>
<li><strong>Database connectivity</strong> provided by the <code class="language-kotlin">java.sql</code> known as JDBC–Java Database Connectivity.</li>
<li>... and more.</li>
</ul>
<p>Because of Kotlin's interoperability with Java, all these functionalities can be utilized in Kotlin as well. This means that as a Kotlin developer, you have access not only to the Kotlin standard library but also to the comprehensive Java standard library, where you can access all of its functionalities with no need to specify any kind of dependency in the <code class="language-kotlin">build.gradle(.kts)</code> file.</p>
<p>Here's an example showing the use of the Java <code class="language-kotlin">BigInteger</code> class in Kotlin:</p>
<pre><code class="language-kotlin">import java.math.BigInteger

fun factorial(n: Int): BigInteger {
    return when (n) {
        0 -&gt; BigInteger.ONE
        else -&gt; BigInteger.valueOf(n.toLong()) * factorial(n - 1)

    }
}

fun main() {
    println(factorial(21)) // 51090942171709440000
}</code></pre>
<p>In this example, we're using the <code class="language-kotlin">BigInteger</code> class from the <code class="language-kotlin">java.math</code> package to calculate the factorial of a number.</p>
<p>When you're using a Java library in Kotlin, you can call its methods, inherit from its classes, and implement its interfaces just like you would in Java. Kotlin even provides some <strong><a class="theory-lookup" href="/learn/step/30148" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, syntactic sugar refers to the language's syntax that makes the code more readable and concise without changing its meaning or behavior. | One example of syntactic sugar in Kotlin is scope functions, such as `let`, `run`, `with`, `apply`, and `also`. These functions do not perform any specific action but organize the code and execute certain operations in the object context. They create a temporary scope for the object and invoke code from a lambda expression. Scope functions allow for more concise and expressive code by enabling communication with the object using the keywords `it` or `this` within the lambda. This syntax can make the code look similar to a domain-specific language (DSL), which can improve code readability and maintainability. While using scope functions can make the code more concise and readable, it is essential to use them judiciously, as excessive use can make the code harder to understand and maintain.">syntactic sugar</a></strong> that makes using Java libraries more idiomatic and enjoyable in Kotlin.</p>
<p>For example, when using a Java library that makes use of getters and setters, Kotlin allows you to use property access <a class="theory-lookup not-relevant" href="/learn/step/33986" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a syntax refers to the set of rules and conventions that dictate how a program should be written in the language. | It includes the structure of statements, expressions, and keywords, as well as the use of indentation, whitespace, and comments. An expression, for example, is a type of syntax that evaluates to a single value, such as a literal value, variable, function call, or a combination of these elements using operators. Understanding the syntax of Kotlin is essential for writing clear, maintainable, and error-free code.">syntax</a>:</p>
<pre><code class="language-kotlin">import java.util.*

fun main() {
    val date = Date()
    val time = date.time // Calls the 'getTime' getter method
    date.time = time + 3600000 // Calls the 'setTime' setter method
}</code></pre>
<p>While Kotlin's Java interoperability is generally seamless, there can be some minor challenges due to differences in language features and idioms. For example, Java's nullability semantics are different from Kotlin's, which can lead to nullability issues when using Java libraries in Kotlin.</p>
<p>Kotlin provides <strong>null-safety</strong> by distinguishing nullable and <a class="theory-lookup" href="/learn/step/7613" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a non-nullable type is a variable that cannot hold a null value. | By default, variables in Kotlin are non-nullable. If you try to assign or return null to a non-nullable variable, the compiler will give an error. This feature helps to prevent null reference errors and makes the code more stable and easy to maintain. In contrast, a nullable type is a variable that can hold a null value. To declare a variable that can hold a null value, you append a question mark to the type.">non-nullable types</a> at the language level. However, when calling Java code from Kotlin, the null-safety guarantees can't be ensured because Java doesn't have this distinction.</p>
<p>To overcome this, Kotlin treats types coming from Java as <strong><a class="theory-lookup not-relevant" href="/learn/step/33986" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a platform type is a data type that can be used as a type variable, which extends or implements a class or interface. | This concept is particularly useful in Kotlin, as it does not support multiple inheritance, but allows a class to implement an unlimited number of interfaces. Platform types are used in generic programming, where one or more type parameters are defined and then used inside the class body for fields, methods, constructor arguments, and return values. The class does not depend on the type it operates on; the type matters only when creating an instance of such a class.">platform types</a></strong>, which leaves the nullability checks to the developer. When using a Java library, you should check whether methods can return null and handle the nullability appropriately in your Kotlin code.</p>
<p>Let's consider an example where we're using the <code class="language-kotlin">java.util.HashMap</code> class from Java in our Kotlin code:</p>
<pre><code class="language-kotlin">import java.util.HashMap

fun main() {
    val map = HashMap&lt;String, String&gt;()
    map["key"] = "value"
    
    val value: String = map["key"]
    println(value.length)
}</code></pre>
<p>In the above code, we're trying to access a value from the <code class="language-kotlin">HashMap</code> using a <code class="language-kotlin">key</code>. In Java, if the <code class="language-kotlin">key</code> doesn't exist in the <code class="language-kotlin">map</code>, the <code class="language-kotlin">get</code> method returns <code class="language-kotlin">null</code>. However, in Kotlin, we're trying to assign the result to a non-nullable <code class="language-kotlin">String</code> variable. This could potentially result in a <code class="language-kotlin">NullPointerException</code> at runtime if the <code class="language-kotlin">key</code> doesn't exist in the <code class="language-kotlin">map</code>.</p>
<p>To avoid this, we should handle the nullability appropriately in our Kotlin code:</p>
<pre><code class="language-kotlin">import java.util.HashMap

fun main() {
    val map = HashMap&lt;String, String&gt;()
    map["key"] = "value"
    
    val value: String? = map["key"]
    println(value?.length)
}</code></pre>
<p>In this updated code, we're assigning the result of the <code class="language-kotlin">get</code> method to a nullable <code class="language-kotlin">String</code> variable and using the <a class="theory-lookup" href="/learn/step/7619" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a safe call is a way to call a member function or property accessor on an object that may be null, without causing a NullPointerException. | It is denoted by the `?.` syntax, which means if the object is not null, call the member function or access the property; otherwise, return null. This allows for more concise and safer code, especially when dealing with potentially null objects. It is particularly useful in situations where the object being called on may not always be initialized or may be null due to asynchronous operations or data fetching.">safe call</a> operator (<code class="language-kotlin">?.</code>) to access the <code class="language-kotlin">length</code> property. This way, we ensure that our code won't throw a <code class="language-kotlin">NullPointerException</code> even if the <code class="language-kotlin">key</code> doesn't exist in the <code class="language-kotlin">map</code>.</p>
<h5 id="best-practices">Best practices</h5>
<p>Using libraries can significantly boost your productivity and enhance the capabilities of your applications. However, it's important to follow some <a class="theory-lookup not-relevant" href="/learn/step/33986" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a best practice refers to a recommended approach or guideline that, when followed, can lead to more efficient, maintainable, and secure code. | When using libraries, for example, it's considered a best practice to thoroughly understand the library you're using, follow its guidelines, and utilize available resources such as documentation and community support. This helps ensure that your use of libraries doesn't introduce issues down the line and allows you to make the most of their functionality. Additionally, best practices can help safeguard the confidentiality and integrity of communications, mitigating the risks associated with unauthorized access and data breaches.">best practices</a> to ensure that your use of libraries doesn't introduce problems down the line. Here are some best practices to keep in mind:</p>
<ul>
<li><strong>Understand the library's functionality</strong>. Before using a library, make sure you understand what it does and how it works. This can help you use the library more effectively and avoid potential issues.</li>
<li><strong>Check the library's documentation and support</strong>. Good libraries usually have comprehensive documentation and active community support. These resources can be invaluable when you're trying to understand how to use the library or when you run into problems.</li>
<li><strong>Be aware of the library's size and performance impact</strong>. Libraries can add to the size of your application and impact its performance. Always consider these factors when choosing a library (especially if it has transitive dependencies).</li>
<li><strong>Keep libraries up to date</strong>. Libraries are often updated with new features, performance improvements, patches for security vulnerabilities, and bug fixes. Make sure to keep your libraries up to date to benefit from these improvements.</li>
<li><strong>Handle potential incompatibilities</strong>. If you're using multiple libraries, there might be incompatibilities between them. Always test your application thoroughly when adding or updating libraries.</li>
<li><strong>Check the library's license</strong>. Make sure the library's license is compatible with how you plan to use it.</li>
</ul>
<h5 id="conclusion">Conclusion</h5>
<p>Libraries are an essential part of programming in Kotlin, providing pre-built functionalities that can extend the language's capabilities and simplify the coding process. They can be categorized into standard libraries, which are included with the language and provide essential functionalities, and<strong> </strong>third-party libraries, which offer specialized or advanced features. Kotlin also offers seamless interoperability with Java, allowing developers to leverage the vast ecosystem of existing Java libraries.</p>
<p>To effectively use libraries, it's important to understand their functionalities and how to integrate them into your projects, which typically involves specifying dependencies and importing packages. Managing library dependencies can be challenging, particularly in large projects, but tools like Gradle can help to automate this process. It's also crucial to keep libraries up to date, be aware of their size and performance impact, handle potential incompatibilities, and ensure their licenses are compatible with your intended use.</p>
<p>Finally, remember that while libraries can significantly boost your productivity and enhance the capabilities of your applications, they should be used judiciously. Always strive to understand the libraries you're using, follow best practices, and use the resources available to you, such as documentation and community support, to get the most out of them.</p>
<p>Now, happy practicing.</p>
</div>